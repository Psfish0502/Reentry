//開發版使用wemos D1 R1 

#include <ESP8266WiFi.h>
#include <WiFiUdp.h>
#include <SPI.h>
#include <MFRC522.h>

#define RST_PIN    D2     // Reset腳
#define SS_PIN    D4    // 晶片選擇腳

#ifndef STASSID
#define STASSID "Reentry"//你的WIFI名稱
#define STAPSK  "reentry104"//WIFI密碼
#endif

WiFiUDP Udp;//宣告使用UDP
unsigned int localPort = 10000;//arduino接收訊息的port
char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; //宣告封包資料

MFRC522 mfrc522(SS_PIN, RST_PIN);    // 建立MFRC522物件
MFRC522::MIFARE_Key key;  
MFRC522::StatusCode status;
byte sector = 15;   
byte block = 1;     
byte buffer[18];

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);//wifi模式
  WiFi.begin(STASSID, STAPSK);//開始連線至指定wifi，並使用設定的密碼
  while (WiFi.status() != WL_CONNECTED) {//成功連線前print...，成功連線print"WL_CONNECTED"
    Serial.print('.');
    delay(500);
  }
  Serial.print("Connected! IP address: ");
  Serial.println(WiFi.localIP());
  Serial.printf("UDP server on port %d\n", localPort);
  Udp.begin(localPort);

   SPI.begin();              
  mfrc522.PCD_Init();        
  Serial.println(F("Please scan "));
  for (byte i = 0; i < 6; i++) {
    key.keyByte[i] = 0xFF; }

}
void loop() {

    mfrc522.PCD_Init();
    if(mfrc522.PICC_IsNewCardPresent() && mfrc522.PICC_ReadCardSerial()){
    readBlock(sector, block, buffer);      
    Serial.print(F("Read block: "));        
    for (byte i = 0 ; i < 16 ; i++) {
      Serial.write (buffer[i]); 
      }
      Serial.println();
      mfrc522.PICC_HaltA();
      delay(3000);
      Serial.println(F("Please scan "));
      }
      
    int packetSize = Udp.parsePacket();//宣告一個封包資料的大小
    if(packetSize)//如果接收到封包資料，執行下面的指令
    {
    Serial.print("Received packet of size ");
    Serial.println(packetSize);//print 封包資料大小
    Serial.print("From ");
    IPAddress remote = Udp.remoteIP();//print出udp sender的ip位址
    for (int i =0; i < 4; i++){
      Serial.print(remote[i], DEC);
      if (i < 3){Serial.print(".");}}
    Serial.print(", port ");
    Serial.println(Udp.remotePort());//print出udp sender的port
    // read the packet into packetBufffer
    Udp.read(packetBuffer,UDP_TX_PACKET_MAX_SIZE);//讀取接收到的封包資料，資料格式為陣列的char
    
    Serial.print("Contents:");
    Serial.println(packetBuffer);//print 封包資料的內容
    
    int Anum = (int)packetBuffer[0] ;//將封包資料的資料型態從char轉換成int，此處為ascii轉換。
    //注意傳送的是char的陣列，因此必須定義陣列的第幾個元素
    
    Serial.print("After convert to int:");
    Serial.println(Anum);//print出轉換過後的int資料
   
    char  ReplyBuffer[]="Reeentry_005";//回傳的內容  
    
    Serial.print("ReplyBuffer:");
    Serial.println(ReplyBuffer);//print出回傳的字串
    
    if(packetBuffer[0] == 'g'){Serial.println("receive g");}//如果接收到的資料[0]是'g'，print出"receive g"
    
    Udp.beginPacket(Udp.remoteIP(), 7777);//開始進行封包資料包裝，傳送到Udp.remoteIP()，port為8888。
    //Udp.remoteIP():udp sender的ip位址
    //port:要在sender那邊另開一個port，不可與此處的receiver同port
    Udp.write("/2");//一共有4塊wemos，每塊的代號
    Udp.write(ReplyBuffer);//傳送的資料為ReplyBuffer 希望可以傳送rfid讀取到的資料
    Udp.endPacket();//結束封包，正式傳送
    //傳送的資料格式：將字串中的字元轉換成int傳輸，透過ascii轉換。因此sender接收時要分辨出這個格式。
    //格式舉例：字串內容為test，傳輸出去為116 101 115 116 0000000
    }
}
//班上晶片代號限定範圍 資料: Reentry_XXX(XXX為001-100)
void readBlock(byte _sector, byte _block, byte _blockData[])  {
  if (_sector < 0 || _sector > 15 || _block < 0 || _block > 3) {
    Serial.println(F("Wrong sector or block number."));
    return; }
  byte blockNum = _sector * 4 + _block;  
  byte trailerBlock = _sector * 4 + 3;   
  status = (MFRC522::StatusCode) mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, &key, &(mfrc522.uid));
  if (status != MFRC522::STATUS_OK) {  
    Serial.print(F("PCD_Authenticate() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return;
    }
  byte buffersize = 18;
  status = (MFRC522::StatusCode) mfrc522.MIFARE_Read(blockNum, _blockData, &buffersize);
  if (status != MFRC522::STATUS_OK) { 
    Serial.print(F("MIFARE_read() failed: "));
    Serial.println(mfrc522.GetStatusCodeName(status));
    return; 
    }
  Serial.println(F("Data was read."));
}
